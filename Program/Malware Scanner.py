import os,time,logging #os-used for interacting with the OS;time-used for adding delays within code;logging-used for writing log messages
import tkinter as tk #used for making GUIs(graphical user interfaces)
from tkinter import scrolledtext#allow for text widget
from tkinter import filedialog#creating file/directory selection windows.
import tkinter.simpledialog as tk_simpledialog#Gets input from tkinter
import threading
from threading import Thread #Allows you to implement threading(running functions concurrently)
import psutil#Used for retrieving info on processes and system utilization
import re #Supports regular expressions
import shutil #used for file operations(copying,moving,deleting,comparing etc)
from scapy.all import * #used for packet capturing-for DoS and packet snifffer detection
from datetime import datetime, timedelta #Used for handling date and time operations.
from scapy.all import sniff# Used for packet capturing
from scapy.layers.inet import ICMP,TCP,IP
import socket # Used for detecting network communication and connections
from scapy.layers.l2 import Ether
from scapy.layers.http import HTTPRequest
import subprocess# Used for running system commands or subprocesses
#from scapy.sendrecv import sniff
import pyshark# Provides a Python wrapper for tshark, useful for packet analysis
import ipaddress # Provides classes representing IP addresses and networks
import sys # Provides access to some variables used or maintained by the Python interpreter
import fnmatch # Supports Unix-style filename pattern matching.
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler # Allows monitoring file system events.
from watchdog.events import FileCreatedEvent, FileDeletedEvent, FileMovedEvent, FileModifiedEvent
import math # Provides mathematical functions.
import time #handlles time operations
from PIL import Image, ImageTk#opening, manipulating, and saving many different image file formats.
import mimetypes #Aquire data about a file's MIME type
import docx  # For handling .docx files
import PyPDF2  # For handling PDF files
import openpyxl  # For handling .xlsx files
from pptx import Presentation  # For handling .pptx files
import pytesseract #For using OCR data extraction processes to extract malicious embedded files from within JPEG and PNG images.
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'


selected_folder = ""
detected_processes = []

scan_folder = ""  # Will be set when the user selects a folder
stop_live_scanner_flag = False  # Flag to indicate whether to stop the scanner
stop_folder_scanner_flag = False

# Configure logging
logging.basicConfig(level=logging.INFO, filename='scan_log.txt', filemode='a',
                    format='%(asctime)s - %(levelname)s - %(message)s')

target_ports = [20, 21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 587, 3389]
# 20/21-FTP,22-SSH,23-Telnet,25-SMTP,53-DNS,80-HTTP,110-POP3,143-IMAP,443-HTTPS,445-SMB,587-encrypted SMTP,3389-RDP


#keywords for malware based on programming language; keywords for packet sniffer, keylogger, denial of servoice, ransomware and reverse shell scripts
exemalware_keywords = ["GetAsyncKeyState", "SetWindowsHookEx", "flood", "udp", "tcp", "encrypt", "decrypt", "ransom", "pcap", "sniff", "capture"]
pymalware_keywords = ['socket.socket', 'subprocess.Popen', 'os.popen', 'pty.spawn', 'pty.fork', 'socket.create_connection', 'socket.settimeout', 'urllib.request.urlopen', 'requests.get', 'requests.post', 'threading.Thread', 'pynput.keyboard.Listener', 'keylogger', 'keyboard', 'keyboard.on_press', 'pyHook.HookManager', 'ctypes.windll.user32.GetKeyState', 'scapy.sniff', 'socket.AF_PACKET', 'socket.SOCK_RAW', 'pcapy.open_live', 'dpkt.ethernet.Ethernet', 'scapy', 'pcapy','sniff','sniffer', 'tcpdump','packet capture','os.walk', 'os.remove', 'os.system', 'os.rename', 'shutil.rmtree','pycryptodome.Cipher', 'pycryptodome.PublicKey', 'pycryptodome.Random', 'encrypt', 'ransom', 'socket']
csharpmalware_keywords = ["Keylogger|GetAsyncKeyState", "nativekeypressed", 'TcpClient', 'TcpListener', 'Process.Start', 'System.Net.Sockets', 'System.Diagnostics.Process', "Thread.Sleep", "Task.Delay", 'File.WriteAllText', 'FileStream.Write', 'NetworkInterface', 'PacketCapture', 'System.Net.Sockets.TcpClient', 'System.Net.Sockets.NetworkStream', 'System.Net.WebRequest', 'System.Net.Http.HttpClient', 'InputSimulator', 'KeyboardHookListener', 'System.Windows.Forms.Keys', 'GetAsyncKeyState', 'SharpPcap', 'PacketDevice.Open', 'PacketCommunicator', 'SharpPcap.RawCapture', 'PacketDotNet.EthernetPacket', 'Directory.GetFiles', 'File.Delete', 'File.Move', 'File.ReadAllBytes', 'File.WriteAllBytes', 'File.Encrypt', 'File.Decrypt']
cmalware_keywords = ['socket', 'winsock', 'CreateProcess', 'system', 'ShellExecute', 'getaddrinfo', 'connect', 'send', 'recv', 'Sleep', 'CreateThread', 'GetAsyncKeyState', 'SetWindowsHookEx', 'GetKeyState', 'getch', 'getchar', 'RegisterHotKey', 'usleep', 'fwrite', 'fread', 'keybd_event', 'WH_KEYBOARD_LL', 'socket', 'winsock', 'WSASocket', 'WSARecv', 'libpcap', 'pcap_open_live', 'pcap_compile', 'pcap_setfilter', 'pcap_open_live' 'FindFirstFile', 'FindNextFile', 'DeleteFile', 'MoveFile', 'CreateFile', 'WriteFile', 'CryptEncrypt', 'CryptDecrypt', 'encrypt', 'decrypt']
javamalware_keywords = ['java.net.Socket', 'java.net.ServerSocket', 'java.io.BufferedReader', 'java.io.InputStreamReader', 'java.lang.Runtime', 'java.net.Socket', 'java.net.HttpURLConnection', 'java.net.URL', 'java.net.InetAddress', 'java.util.concurrent.ThreadPoolExecutor', 'java.awt.event.KeyEvent', 'java.awt.Robot', 'java.util.logging.Logger', 'javax.swing.KeyStroke', 'JpcapCaptor', 'JpcapSender', 'JpcapPacket', 'PcapPacketHandler', 'JpcapWriter', 'java.nio.file.Files', 'java.nio.file.Path', 'java.nio.file.Paths', 'java.nio.file.StandardCopyOption', 'javax.crypto.Cipher']
allmalwarekeywords= exemalware_keywords+pymalware_keywords+csharpmalware_keywords+cmalware_keywords+javamalware_keywords
def Scan_File(file_path,allmalwarekeywords):
    try:
        with open(file_path, 'rb') as file:
            content = file.read()
            file_extension = os.path.splitext(file_path)[1].lower()

            # Binary file extensions
            binary_extensions = ['.exe']
            if file_extension in binary_extensions:
                if any(keyword.encode('utf-8') in content for keyword in exemalware_keywords):
                    alert_message = f"Alert! Malicious keywords found in file: {file_path}"
                    return True
                exe_shellcode_pattern = re.compile(rb'\\x[0-9a-fA-F]{2}')  # checks for shellcode in an exe file.
                if exe_shellcode_pattern.search(content):
                    alert_message = f"Alert! Malicious shellcode pattern found in file: {file_path}"
                    return True
            else:
                try:
                    content_str = content.decode('utf-8', errors='ignore')

                    # Additional checks for text file extensions
                    file_extension = os.path.splitext(file_path)[
                        1].lower()
                    document_extensions = ['.doc', '.pdf', '.docx', '.xlsx', '.pptx']
                    if file_extension in document_extensions:
                        # Handle each document type separately
                        if file_extension == '.doc':  # For .doc files
                            doc_content = docx.Document(file_path).read_text()
                            keyword_count = sum(
                                keyword.lower() in doc_content.lower() for keyword in allmalwarekeywords)
                            if keyword_count >= 2:
                                return True

                        elif file_extension == '.txt':
                            # Check for keywords in TXT files
                            keyword_count = sum(
                                keyword.lower() in content_str.lower() for keyword in allmalwarekeywords)
                            if keyword_count >= 2:
                                return True

                        elif file_extension == '.pdf':  # For .pdf files
                            pdf_content = ""
                            pdf_reader = PyPDF2.PdfReader(file_path)
                            for page in pdf_reader.pages:
                                pdf_content += page.extract_text()
                            keyword_count = sum(
                                keyword.lower() in pdf_content.lower() for keyword in allmalwarekeywords)
                            if keyword_count >= 2:
                                return True

                        elif file_extension == '.docx':  # For .docx files
                            docx_content = ""
                            doc = docx.Document(file_path)
                            for paragraph in doc.paragraphs:
                                docx_content += paragraph.text
                            keyword_count = sum(
                                keyword.lower() in docx_content.lower() for keyword in allmalwarekeywords)
                            if keyword_count >= 2:
                                return True

                        elif file_extension == '.xlsx':  # For .xlsx files
                            wb = openpyxl.load_workbook(file_path)
                            keyword_count = 0
                            for sheet in wb.worksheets:
                                for row in sheet.iter_rows():
                                    for cell in row:
                                        if cell.value and any(keyword.lower() in str(cell.value).lower() for keyword in
                                                              allmalwarekeywords):
                                            keyword_count += 1
                                            if keyword_count >= 2:
                                                return True

                        elif file_extension == '.pptx':  # For .pptx files
                            prs = Presentation(file_path)
                            pptx_content = ""
                            for slide in prs.slides:
                                for shape in slide.shapes:
                                    if hasattr(shape, "text"):
                                        pptx_content += shape.text
                            keyword_count = sum(
                                keyword.lower() in pptx_content.lower() for keyword in allmalwarekeywords)
                            if keyword_count >= 2:
                                return True

                    image_extensions=['.jpeg', '.jpg', '.png']
                    if file_extension in image_extensions:
                        # Perform OCR to extract text from the image
                        image = Image.open(file_path)
                        extracted_text = pytesseract.image_to_string(image)
                        # Check the extracted text for malicious keywords
                        if any(keyword.lower() in extracted_text.lower() for keyword in allmalwarekeywords):
                            alert_message = f"Alert! Malicious keywords found in image: {file_path}"
                            return True

                    elif file_extension == '.py':#Python
                        keyword_count = 0
                        for keyword in pymalware_keywords:
                            if keyword.lower() in content_str.lower():
                                keyword_count += 1
                            if keyword_count >= 2:#check for at least 2 keywords
                                return True
                    elif file_extension == '.cs':#C Sharp
                        keyword_count = 0
                        for keyword in csharpmalware_keywords:
                            if keyword.lower() in content_str.lower():
                                keyword_count += 1
                            if keyword_count >= 2:
                                return True
                    elif file_extension == '.c':#C
                        keyword_count = 0
                        for keyword in cmalware_keywords:
                            if keyword.lower() in content_str.lower():
                                keyword_count += 1
                            if keyword_count >= 2:
                                return True
                    elif file_extension == '.java':#Java
                        keyword_count = 0
                        for keyword in javamalware_keywords:
                            if keyword.lower() in content_str.lower():
                                keyword_count += 1
                            if keyword_count >= 2:
                                return True
                    exe_shellcode_pattern = re.compile(b"\\\\x[0-9a-fA-F]{2}")  # checks for shellcode in the above file types
                    if exe_shellcode_pattern.search(content):
                        return True
                    else:
                        pass  # skips any file that isn't python, C#, visual basic, c or java

                except (UnicodeDecodeError, PermissionError, FileNotFoundError) as e:
                    logging.error(f"Error reading {file_path}: {e}", exc_info=True)

    except (PermissionError, FileNotFoundError) as e:
        logging.error(f"Error reading {file_path}: {e}", exc_info=True)
    return False

def Capture_Malicious_File(file_path, destination_folder):#Copies any malicious file and sends them to the destination folder(in this instance "Captured_Scripts")
    try:
        shutil.copy(file_path, destination_folder)
        logging.info(f"Malicious file captured and contained: {file_path}")
    except Exception as e:
        logging.error(f"Error capturing malicious file: {e}", exc_info=True)

def Scan_Directory(directory, allmalwarekeywords, output_text):
    malware_found = False

    for root, dirs, files in os.walk(directory):
        dirs = dirs or []

        for file in files:
            file_path = os.path.join(root, file)
            file_extension = os.path.splitext(file_path)[1].lower()

            if file_extension not in ['.py', '.cs', '.c', '.java','.doc', '.pdf', '.docx', '.xlsx', '.pptx', '.jpeg', '.jpg', '.png']:
                continue  # Skip scanning this file

            if Scan_File(file_path, allmalwarekeywords):
                malware_found = True
                alert_message = f"Alert! Potential Malware! Malicious keywords found in: {file_path}"
                output_text.insert(tk.END, str(alert_message) + "\n")
                logging.warning(alert_message)
                Capture_Malicious_File(file_path, "Captured_Scripts")

        for subdir in dirs:
            subdir_path = os.path.join(root, subdir)
            Scan_Directory(subdir_path, allmalwarekeywords, output_text)

    if not malware_found:
        output_text.insert(tk.END, "All (other) files here are safe.\n")
        logging.info("No malware found")

def Start_Scanner(allmalwarekeywords, output_text):
    global scan_folder
    scan_folder = filedialog.askdirectory()
    output_text.insert(tk.END, f"Scan folder selected: {scan_folder}\n")
    Scan_Directory(scan_folder, allmalwarekeywords, output_text)
def DoS_Detection(output_text):
    try:
        # Define a list of commonly targeted ports for DoS attacks
        dos_ports = target_ports  # Example ports commonly targeted for HTTP and HTTPS DoS attacks

        # Get the IP address of the local machine
        local_ip = socket.gethostbyname(socket.gethostname())

        # Initialize a dictionary to store counts of packets per source IP address
        packet_counts = {}

        # Packet callback function
        def Packet_Callback(packet):
            if packet.haslayer(IP) and packet[IP].dst == local_ip:
                src_ip = packet[IP].src
                dst_port = packet[IP].dport

                # Check if the packet's destination port matches any of the DoS target ports
                if dst_port in dos_ports:
                    if src_ip in packet_counts:
                        packet_counts[src_ip] += 1
                    else:
                        packet_counts[src_ip] = 1

                    # Check if the number of packets from a single source IP exceeds a threshold
                    dos_threshold = 100  # Adjust as needed based on expected traffic
                    if packet_counts[src_ip] >= dos_threshold:
                        dos_message = f"Potential DoS attack detected from {src_ip} on port {dst_port}"
                        output_text.insert(tk.END, str(dos_message) + "\n")
                        logging.warning(dos_message)

        sniff(prn=Packet_Callback, store=False, timeout=60)

    except Exception as e:
        logging.error(f"Error in DoS detection: {e}", exc_info=True)

def Is_File_Encrypted(file_path, output_text):
    encryption_signatures = [
        b"gAAAA",  # Fernet
        b"Salted__",  # OpenSSL
        b"BEGIN RSA PRIVATE KEY",  # RSA private key
        b"BEGIN DSA PRIVATE KEY",  # DSA private key
        b"BEGIN EC PRIVATE KEY",  # EC private key
        b"-----BEGIN PGP PRIVATE KEY BLOCK-----",  # PGP private key block
        b"-----BEGIN ENCRYPTED PRIVATE KEY-----",  # Encrypted private key
        b"-----BEGIN CERTIFICATE-----",  # Certificate
        b"-----BEGIN ENCRYPTED MESSAGE-----",  # Encrypted message
        b"-----BEGIN PKCS7-----",  # PKCS7 (Cryptographic Message Syntax Standard)
        b"-----BEGIN PGP MESSAGE-----",  # PGP message
        b"-----BEGIN GPG MESSAGE-----",  # GPG message
    ]
    try:
        # Check file extension
        _, file_extension = os.path.splitext(file_path)
        file_extension = file_extension.lower()

        # Check if the file extension matches common encrypted file extensions
        encrypted_extensions = ['.wcry', '.wnry','.wncry','.locky', '.cerber', '.zepto', '.crysis', '.lockyv2']
        if file_extension in encrypted_extensions:
            output_text.insert(tk.END, f"File {file_path} has a known encrypted file extension.\n")
            return True

        # Get the MIME type of the file
        mime_type, _ = mimetypes.guess_type(file_path)
        if mime_type is not None:
            # Extract the extension from the MIME type
            _, file_extension = os.path.splitext(file_path)
            file_extension = file_extension.lower()
            mime_extension = mimetypes.guess_extension(mime_type)

            # Compare the file extension to the MIME type's extension
            if file_extension != mime_extension:
                output_text.insert(tk.END,f"Warning: File extension ({file_extension}) does not match MIME type ({mime_extension}).\n")

        # Open the file in binary mode for reading
        with open(file_path, 'rb') as file:
            # Read a portion of the file for signature analysis
            data = file.read(1024)  # Read the first 1024 bytes of the file
            # Check for known encryption signatures
            for signature in encryption_signatures:
                if data.startswith(signature):
                    output_text.insert(tk.END, f"File {file_path} appears to be encrypted.\n")
                    return True
    except (FileNotFoundError, PermissionError, UnicodeDecodeError) as e:
        output_text.insert(tk.END, f"Error checking file {file_path}: {e}\n")
        return True
    except Exception as e:
        # Handle other exceptions gracefully
        output_text.insert(tk.END, f"Error checking file {file_path}: {e}\n")
        return True
    return False

def Scan_For_Locked_Files(output_text):
    global selected_folder
    selected_folder = filedialog.askdirectory()
    output_text.insert(tk.END, f"Scanning for locked files...\n")
    locked_files_found = False

    for root, dirs, files in os.walk(selected_folder):
        for file in files:
            file_path = os.path.join(root, file)

            if Is_File_Encrypted(file_path, output_text):
                alert_message = f"Alert! Locked file found"
                output_text.insert(tk.END, str(alert_message) + "\n")
                logging.warning(alert_message)
                locked_files_found = True

    if not locked_files_found:
        output_text.insert(tk.END, f"No locked files found.\n")

    output_text.insert(tk.END, f"Scan for locked files complete.\n")


def Keylogger_Detector(output_text, interval_seconds=185, threshold=3):
    try:
        cap_filter = 'port 20 or port 21 or port 587'
        message_times = {}
        log_files_created = {}

        def Keylogger_Packet_Callback(packet):
            if TCP in packet and packet[TCP].dport in [20, 21, 587]:
                dst_ip = packet[IP].dst
                current_time = datetime.now()
                message_times.setdefault(dst_ip, []).append(current_time)
                repeated_messages = [time for time_list in message_times.values() for time in time_list if
                                     (current_time - time).total_seconds() <= interval_seconds]
                if len(repeated_messages) >= threshold:
                    alert_message = f"Repeated messages detected to port {packet[TCP].dport} at IP {dst_ip} within {interval_seconds} seconds! This indicates a potential keylogger active on your device"
                    output_text.insert(tk.END, str(alert_message) + "\n")
                    logging.warning(alert_message)

            # Check for newly created log files
            for root, dirs, files in os.walk('/var/log'):  # Adjust the directory path as needed
                for file in files:
                    filepath = os.path.join(root, file)
                    if filepath not in log_files_created:
                        creation_time = os.path.getctime(filepath)
                        if (current_time - creation_time) <= interval_seconds:
                            log_files_created[filepath] = current_time
                            alert_message = f"New log file created: {filepath}"
                            output_text.insert(tk.END, str(alert_message) + "\n")
                            logging.warning(alert_message)

        sniff(filter=cap_filter, prn=Keylogger_Packet_Callback, store=False, timeout=60)

    except Exception as e:
        logging.error(f"Error in tracking port activity: {e}", exc_info=True)


def Packet_Sniffer_Detection(output_text):
    try:
        # List of popular packet sniffing processes/applications to check for
        sniffing_processes = ["Wireshark.exe", "tcpdump.exe", "WinPcap.exe"]
        for proc in psutil.process_iter(["name"]):
            if proc.info["name"] in sniffing_processes:
                alert_message = f"Potential packet sniffing process detected: {proc.info['name']}"
                output_text.insert(tk.END, str(alert_message) + "\n")
                logging.warning(alert_message)
        raw_sockets = []        # Check for raw socket creation on both Linux and Windows
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                connections = proc.connections(kind='all')
            except (psutil.NoSuchProcess):
                continue
            for conn in connections:
                if conn.family in (psutil.AF_INET, psutil.AF_INET6) and conn.type == socket.SOCK_RAW:
                    raw_sockets.append((proc.pid, conn.fd))
                    break
        if raw_sockets:
            alert_message = "Raw socket(s) created by program(s):"
            for pid, fd in raw_sockets:
                alert_message += f"\nPID: {pid}, FD: {fd}"
            output_text.insert(tk.END, str(alert_message) + "\n")
            logging.warning(alert_message)
        # Check for promiscuous mode
        network_interfaces = psutil.net_if_addrs()
        for interface, addresses in network_interfaces.items():
            for address in addresses:
                if address.family == psutil.AF_LINK and address.address == "00:00:00:00:00:00":
                    alert_message = f"Promiscuous mode detected on interface: {interface}"
                    output_text.insert(tk.END, str(alert_message) + "\n")
                    logging.warning(alert_message)
        for proc in psutil.process_iter(): # Check for suspicious network privileges
            try:
                if proc.connections(kind='inet') and proc.username() != 'SYSTEM':
                    alert_message = f"Suspicious process {proc.name()} with raw sockets or elevated network privileges!"
                    output_text.insert(tk.END, str(alert_message) + "\n")
                    logging.warning(alert_message)
            except psutil.AccessDenied:
                continue

    except Exception as e:
        logging.error(f"Error in packet sniffing activity: {e}", exc_info=True)

def Is_IPAdress_Private(ip):
    try:
        return ipaddress.ip_address(ip).is_private
    except ValueError:
        return False

def get_my_ip():
    return socket.gethostbyname(socket.gethostname())

def Check_For_Reverse_Shell(output_text):
    my_ip=get_my_ip()
    try:
        while not stop_live_scanner_flag:
            # Get all network connections
            connections = psutil.net_connections(kind='inet')

            # Check for outbound connections
            for conn in connections:
                if conn.status == psutil.CONN_ESTABLISHED:
                    local_ip, local_port = conn.laddr
                    remote_ip, remote_port = conn.raddr

                    # Check if the remote IP address is private-will ca
                    if Is_IPAdress_Private(remote_ip) and remote_ip != my_ip:
                    # Check if the connection is outbound and not to a common service port-127.0.0.1 is localhost. port 80 is HTTP and 443 is HTTPS
                        if local_ip != '127.0.0.1' and remote_ip != '127.0.0.1' and remote_port not in [80, 443]:
                            alert_message = f"Potential reverse shell detected: {local_ip}:{local_port} -> {remote_ip}:{remote_port}"
                            output_text.insert(tk.END, str(alert_message) + "\n")
                            logging.warning(alert_message)

            time.sleep(3)
    except Exception as e:
        logging.error(f"Error in reverse shell detection: {e}", exc_info=True)

class FileTransferHandler(FileSystemEventHandler):
    def __init__(self, output_text):
        super().__init__()
        self.output_text = output_text

    def on_created(self, event):
        if isinstance(event, FileCreatedEvent):
            alert_message = f"Alert! File created: {event.src_path}"
            self.output_text.insert(tk.END, str(alert_message) + "\n")
            logging.warning(alert_message)

    def on_deleted(self, event):
        if isinstance(event, FileDeletedEvent):
            alert_message = f"Alert! File deleted: {event.src_path}"
            self.output_text.insert(tk.END, str(alert_message) + "\n")
            logging.warning(alert_message)

    def on_modified(self, event):
        if isinstance(event, FileModifiedEvent):
            alert_message = f"Alert! File modified: {event.src_path}"
            self.output_text.insert(tk.END, str(alert_message) + "\n")
            logging.warning(alert_message)

    def on_moved(self, event):
        if isinstance(event, FileMovedEvent):
            alert_message = f"Alert! File moved: {event.src_path} -> {event.dest_path}"
            self.output_text.insert(tk.END, str(alert_message) + "\n")
            logging.warning(alert_message)

def start_file_monitoring(base_directory, output_text):
    current_user = os.getlogin()
    base_directory = os.path.join("C:\\Users", current_user, "OneDrive", "Documents")
    event_handler = FileTransferHandler(output_text)
    observer = Observer()
    observer.schedule(event_handler, base_directory, recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

def Read_Standard_Actions():#reads standard_actions.txt to get a list of acceptable actions by the pc(applications regularly accessed by PC.
    standard_actions = []
    file_path = "standard_actions.txt"

    if os.path.exists(file_path):
        with open(file_path, 'r') as file:
            standard_actions = [line.strip() for line in file.readlines()]

    return standard_actions

standard_actions = Read_Standard_Actions()

def Anomaly_Action_Checking(output_text):#Checks for actions occuring that aren't normal to PC based on standard_actions.txt
    try:
        running_processes = [proc.name().lower() for proc in psutil.process_iter(attrs=['name'])]

        # Load standard actions from the file
        with open('standard_actions.txt', 'r') as file:
            standard_actions = set(file.read().splitlines())

        # Check if any process is not in the list of standard actions
        anomalies = [process for process in running_processes if process not in standard_actions]

        if anomalies:
            alert_message = f"Alert! Anomaly detected. Unexpected processes running:{', '.join(anomalies)}"#edited out bit which lists anomalies
            output_text.insert(tk.END, str(alert_message) + "\n")
            logging.warning(alert_message)
            return True

    except Exception as e:
        logging.error(f"Error in anomaly-based process running detection: {e}", exc_info=True)
    return False

def Read_Thresholds_From_File():
    # Get the current directory
    current_directory = os.getcwd()

    # Construct the absolute path to the file
    file_path = os.path.join(current_directory, "resource_usage.txt")

    try:
        with open(file_path, "r") as file:
            lines = file.readlines()
            # Extract CPU threshold from the first line and RAM threshold from the second line
            cpu_threshold = float(lines[0].split(':')[1].strip())
            ram_threshold = float(lines[1].split(':')[1].strip())
            return cpu_threshold, ram_threshold
    except FileNotFoundError:
        # Handle the case when the configuration file is not found
        print("Configuration file not found.")
        return None, None
    except Exception as e:
        # Handle other exceptions (e.g., invalid format)
        print(f"Error reading configuration file: {e}")
        return None, None
# Function to check anomaly-based resource usage
def Anomaly_Resource_Usage(output_text):
    try:
        # Read CPU and RAM thresholds from the configuration file
        cpu_threshold, ram_threshold = Read_Thresholds_From_File()

        if cpu_threshold is None or ram_threshold is None:
            return False  # Return False if thresholds couldn't be read

        # Get CPU usage percentage
        cpu_usage = psutil.cpu_percent(interval=1)
        # Get memory usage percentage
        memory_usage = psutil.virtual_memory().percent

        # Check if CPU usage exceeds the threshold
        if cpu_usage > cpu_threshold:
            alert_message = f"Alert! Abnormal CPU usage detected: {cpu_usage}%"
            output_text.insert(tk.END, str(alert_message) + "\n")
            logging.warning(alert_message)
            return True

        # Check if memory usage exceeds the threshold
        elif memory_usage > ram_threshold:
            alert_message = f"Alert! Abnormal memory usage detected:  {memory_usage}%"
            output_text.insert(tk.END, str(alert_message) + "\n")
            logging.warning(alert_message)
            return True

    except Exception as e:
        logging.error(f"Error in anomaly-based resource usage detection: {e}", exc_info=True)

    return False

def Customization(output_text):
    try:
        # Add standard actions
        password = tk_simpledialog.askstring("Password", "Enter password:", show='*')
        if password == "admin":
            new_processes = tk_simpledialog.askstring("Add Standard Actions", "Enter process names separated by commas:")
            if new_processes:
                # Split the input by commas and add each process individually
                new_processes_list = [process.strip() for process in new_processes.split(',')]
                for new_process_name in new_processes_list:
                    standard_actions.append(new_process_name.lower())
                    output_text.insert(tk.END, f"Added '{new_process_name}' to standard actions.\n")
                    with open("standard_actions.txt", 'a') as file:
                        file.write(f"{new_process_name}\n")

        # Change CPU/RAM thresholds
        cpu_threshold = tk_simpledialog.askfloat("Change CPU Threshold", "Enter CPU threshold (0-100):", minvalue=0, maxvalue=100)
        ram_threshold = tk_simpledialog.askfloat("Change RAM Threshold", "Enter RAM threshold (0-100):", minvalue=0, maxvalue=100)

        # Write the new thresholds to the configuration file
        with open('resource_usage.txt', 'w') as file:
            file.write(f"CPU Threshold: {cpu_threshold}\n")
            file.write(f"RAM Threshold: {ram_threshold}\n")

        output_text.insert(tk.END, f"Customization successful. CPU Threshold changed to {cpu_threshold}% and RAM Threshold changed to {ram_threshold}%.\n")

    except Exception as e:
        output_text.insert(tk.END, f"Error during customization: {e}\n")


def Live_Scan(output_text, base_directory, target_ports):
    output_text.insert(tk.END, "Live scan started\n")
    global stop_live_scanner_flag
    stop_live_scanner_flag = False

    # Start file monitoring in a separate thread
    file_monitor_thread = threading.Thread(target=start_file_monitoring, args=(base_directory, output_text), daemon=True)
    file_monitor_thread.start()

    while not stop_live_scanner_flag:
        if Anomaly_Action_Checking(output_text):
            alert_message = "Alert!-Anomaly unlisted process detected!"
            output_text.insert(tk.END, alert_message + "\n")
            logging.warning(alert_message)

        if Anomaly_Resource_Usage(output_text):
            alert_message = "Alert!-Anomaly CPU/RAM usage detected!"
            output_text.insert(tk.END, alert_message + "\n")
            logging.warning(alert_message)

        Packet_Sniffer_Detection(output_text)

        Keylogger_Detector(output_text)

        reverse_shell_thread = threading.Thread(target=Check_For_Reverse_Shell, args=(output_text,), daemon=True)
        reverse_shell_thread.start()

        sniff(prn=lambda packet: DoS_Detection(output_text), store=False, timeout=60)

def Stop_Live_Scan(output_text):
    global stop_live_scanner_flag
    stop_live_scanner_flag = True
    output_text.insert(tk.END, "Live scan stopped.\n")


def clear_interface(output_text):
    output_text.delete('1.0', tk.END)

def Exit_Program():  # Ends the program
    quit()


def splash_screen():
    splash_root = tk.Tk()
    splash_root.title("Malware scanner")
    splash_root.geometry("450x200")
    # splash_root.configure(bg='blue')

    # Load background image
    background_image = Image.open("ss_background.jpg")
    background_photo = ImageTk.PhotoImage(background_image)

    # Create a label with the background image
    background_label = tk.Label(splash_root, image=background_photo)
    background_label.image = background_photo
    background_label.place(x=0, y=0, relwidth=1, relheight=1)

    label = tk.Label(splash_root, text="Malware scanner by J.Russell", font=("Unispace", 20), bg='green')
    label.pack(expand=True)

    splash_root.after(8000, splash_root.destroy)
    splash_root.mainloop()


def start_splash_and_gui():
    splash_thread = Thread(target=splash_screen)
    splash_thread.start()
    splash_thread.join()
    Create_GUI()


def Create_GUI():
    root = tk.Tk()
    root.title("Malware Scanner")
    root.configure(bg='cyan')

    # Set up grid for layout
    root.columnconfigure(0, weight=1)
    root.columnconfigure(1, weight=3)
    root.rowconfigure(0, weight=1)
    root.rowconfigure(1, weight=3)  # Added row configuration

    # Create frame for output text on the left
    output_frame = tk.Frame(root)
    output_frame.grid(row=0, column=0, padx=10, pady=10, sticky='nsew')

    output_text = scrolledtext.ScrolledText(output_frame, width=60, height=20, bg='gold')  # Colour of output text box
    output_text.pack(expand=True, fill='both')

    # Create frame for buttons on the right
    buttons_frame = tk.Frame(root, bg='navy')
    buttons_frame.grid(row=0, column=1, rowspan=2, padx=10, pady=10, sticky='nsew')  # rowspan changed to 2

    Folder_scan_button = tk.Button(buttons_frame, text="Malware Script Search", bg='green2', relief=tk.GROOVE,
                                   command=lambda: Thread(target=Start_Scanner, args=(allmalwarekeywords, output_text),
                                                          daemon=True).start())
    Folder_scan_button.pack(fill='x', padx=5, pady=5)

    Live_scan_button = tk.Button(buttons_frame, text="Live Scan", bg='cyan', relief=tk.GROOVE,
                                 command=lambda: Thread(target=Live_Scan,
                                                        args=(output_text, selected_folder, target_ports),
                                                        daemon=True).start())
    Live_scan_button.pack(fill='x', padx=5, pady=5)

    Stop_live_scan_button = tk.Button(buttons_frame, text="End live scan", bg='yellow', relief=tk.GROOVE,
                                      command=lambda: Stop_Live_Scan(output_text=output_text))
    Stop_live_scan_button.pack(fill='x', padx=5, pady=5)

    Customization_button = tk.Button(buttons_frame, text="Customization", bg='darkviolet', relief=tk.GROOVE,
                                     command=lambda: Customization(output_text))
    Customization_button.pack(fill='x', padx=5, pady=5)

    Lock_scan_button = tk.Button(buttons_frame, text="Locked Files Search", bg='darkorange', relief=tk.GROOVE,
                                 command=lambda: Thread(target=Scan_For_Locked_Files, args=(output_text,),
                                                        daemon=True).start())
    Lock_scan_button.pack(fill='x', padx=5, pady=5)

    # Add the button to clear the output text
    clear_interface_text_button = tk.Button(buttons_frame, text="Clear Interface", bg='white', relief=tk.GROOVE,
                                         command=lambda: clear_interface(output_text))
    clear_interface_text_button.pack(fill='x', padx=5, pady=5)

    # Create frame for the exit button in the bottom left corner
    exit_frame = tk.Frame(root, bg='black')
    exit_frame.grid(row=1, column=0, padx=10, pady=10, sticky='sw')  # Placed at bottom left
    Quit_button = tk.Button(exit_frame, text="Exit program", bg='red2', relief=tk.GROOVE, command=Exit_Program,
                            width=10, height=2)
    Quit_button.pack(padx=5, pady=5)

    # Create frame for the image near the buttons
    image_frame = tk.Frame(root, bg='black')  # Outer frame of logo
    image_frame.grid(row=1, column=1, padx=6, pady=5, sticky='se')  # Adjusted grid placement

    image = Image.open("Logo.jpg")
    image = image.resize((100, 100), Image.LANCZOS)
    photo = ImageTk.PhotoImage(image)

    label = tk.Label(image_frame, image=photo, bg='black')  # Inner frame
    label.image = photo
    label.pack(side="right", padx=5, pady=5)

    root.mainloop()

if __name__ == "__main__":
    start_splash_and_gui()
